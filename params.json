{"name":"Itunes receipt validator","tagline":"Validate iTunes Transaction and Unified style receipts with local decoding and remote validation.","body":"# iTunes Receipt Validator\r\n\r\n[![Code Climate](https://codeclimate.com/github/mbaasy/itunes_receipt_validator/badges/gpa.svg)](https://codeclimate.com/github/mbaasy/itunes_receipt_validator)\r\n[![Test Coverage](https://codeclimate.com/github/mbaasy/itunes_receipt_validator/badges/coverage.svg)](https://codeclimate.com/github/mbaasy/itunes_receipt_validator/coverage)\r\n[![Build Status](https://travis-ci.org/mbaasy/itunes_receipt_validator.svg?branch=master)](https://travis-ci.org/mbaasy/itunes_receipt_validator)\r\n[![Gem Version](https://badge.fury.io/rb/itunes_receipt_validator.svg)](https://badge.fury.io/rb/itunes_receipt_validator)\r\n\r\n## Decode locally\r\n\r\nThe difference between this gem and any of the alternatives is that it decodes the base64 encoded receipt with our [ItunesReceiptDecoder](https://github.com/mbaasy/itunes_receipt_decoder) library to extract the data from the receipt **without** making a HTTP request to Apple's servers.\r\n\r\n## No redundent HTTP requests\r\n\r\nBecause this library decodes the receipt first, it determins the origin of the receipt before making any HTTP requests. This means you don't need to make an additional request to the sandbox or prduction URLs.\r\n\r\nSecondly, if the receipt can't be decoded, it can't be validated. This will prevent unnecessary requests when you receive fraudulent receipts.\r\n\r\n## Handle any style of receipt\r\n\r\nApple offers two kinds of receipts:\r\n\r\n1. The deprecated [[SKPaymentTransaction transactionReceipt]](https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKPaymentTransaction_Class/#//apple_ref/occ/instp/SKPaymentTransaction/transactionReceipt) and;\r\n1. The Grand Unified Receipt [[NSBundle appStoreReceiptURL]](https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSBundle_Class/#//apple_ref/occ/instp/NSBundle/appStoreReceiptURL)\r\n\r\nValidating both kinds of receipts requires separate logic because the schemas and data are entirely different.\r\n\r\n## Normalize all the things\r\n\r\nNo matter if the receipt is a `[SKPaymentTransaction transactionReceipt]` or `[NSBundle appStoreReceiptURL]`, the responses are normalized with extra helpful methods for all your iOS and OSX receipt validation needs.\r\n\r\n## Need a complete solution?\r\n\r\nWe have a cloud service available at **[mbaasy.com](https://mbaasy.com)**, it takes care of in-app purchase management, receipt validation and reporting so you don't have to. It even offers integration with your own API through webhooks to notify you of new, expired, renewed and cancelled purchases for iOS, OSX and Google Play receipts. It will save you time and money but most of all it allows you to focus on your core project instead of wasting time on receipt validation.\r\n\r\nWe offer this libary because we believe in the Open Source movement, [mbaasy.com](https://mbaasy.com) is built upon a foundation of Open Source projects, so this libary is our way of giving back to the community.\r\n\r\n## Install\r\n\r\nInstall from the command line:\r\n\r\n```sh\r\n$ gem install itunes_receipt_validator\r\n```\r\n\r\nOr include it in your Gemfile:\r\n\r\n```ruby\r\ngem 'itunes_receipt_validator'\r\n```\r\n\r\n## Usage\r\n\r\n### Initialization\r\n\r\n```ruby\r\nvalidator = ItunesReceiptValidator.new(\r\n  base64_encoded_receipt,\r\n  shared_secret: 'your_shared_secret'\r\n) # => ItunesReceiptValidator::Receipt\r\n```\r\n\r\nOr intialize with a block:\r\n\r\n```ruby\r\nshared_secrets = {\r\n  'com.example.app1' => 'shared_secret_for_app1'\r\n  'com.example.app2' => 'shared_secret_for_app2'\r\n}\r\nvalidator = ItunesReceiptValidator.new(base64_encoded_receipt) do |receipt|\r\n  receipt.shared_secret = shared_secrets.fetch(receipt.bundle_id)\r\nend\r\n```\r\n\r\n### BYO HTTP requests\r\n\r\nIf you require more flexibility with upstream HTTP requests to Apple's Validation API you can initialize with your own request method.\r\n\r\n```ruby\r\nvalidator = ItunesReceiptValidator.new(base64_encoded_receipt) do |receipt|\r\n  receipt.shared_secret = 'your_shared_secret'\r\n  receipt.request_method = lambda do |url, headers, body|\r\n    MyFancyRequest.new(url, headers: headers, body: body)\r\n  end\r\nend\r\n```\r\n\r\nYour custom method exposes a HTTP status code and a response body as `status` and `body` respectively.\r\n\r\n### ItunesReceiptValidator::Receipt methods\r\n\r\n```ruby\r\nvalidator.sandbox?\r\n```\r\nReturns true or false (opposite of production?).\r\n\r\n```ruby\r\nvalidator.production?\r\n```\r\nReturns true or false (opposite of sandbox?).\r\n\r\n```ruby\r\nvalidator.bundle_id\r\n```\r\nReturns the bundle_id of the app (e.g. com.mbaasy.ios).\r\n\r\n```ruby\r\nvalidator.transactions\r\n```\r\nReturns a sub-class of `Array`, with transactions sourced locally from the receipt. See [ItunesReceiptValidator::TransactionsProxy methods](#itunesreceiptvalidatortransactionsproxy-methods).\r\n\r\n```ruby\r\nvalidator.latest_transactions\r\n```\r\nReturns a sub-class of `Array`, with transactions sourced from Apple's validation API. See [ItunesReceiptValidator::TransactionsProxy methods](#itunesreceiptvalidatortransactionsproxy-methods).\r\n\r\n```ruby\r\nvalidator.latest_receipt\r\n```\r\nReturns a base64 encoded string for the latest receipt sourced from Apple's validation API.\r\n\r\n```ruby\r\nvalidator.local\r\n```\r\nReturns the `ItunesReceiptDecoder::Decode::Transaction` or `ItunesReceiptDecoder::Decode::Unified` instances. See the [ItunesReceiptDecoder](https://github.com/mbaasy/itunes_receipt_decoder) gem.\r\n\r\n```ruby\r\nvalidator.remote\r\n```\r\nReturns the `ItunesReceiptValidator::Remote` instance.\r\n\r\n### ItunesReceiptValidator::TransactionsProxy methods\r\n\r\nInerhits from [Array](http://apidock.com/ruby/Array) and includes [Enumerable](http://apidock.com/ruby/Enumerable).\r\n\r\n```ruby\r\ntransactions.where(id: 1234)\r\n```\r\nLike ActiveRecord's `where` it accepts a hash of arguments and returns a new instance of `ItunesReceiptValidator::TransactionsProxy`.\r\n\r\n### ItunesReceiptValidator::Transaction methods\r\n\r\n```ruby\r\ntransaction.expired?\r\n```\r\nReturns true or false. This method will make a request to Apple's validation API to check if the receipt itself has expired, or if the latest transaction retrieved is expired.\r\n\r\n```ruby\r\ntransaction.cancelled?\r\n```\r\nReturns true or false.\r\n\r\n```ruby\r\ntransaction.auto_renewing?\r\n```\r\nReturns true if `web_order_line_item_id` is present.\r\n\r\n```ruby\r\ntransaction.trial_period?\r\n```\r\nReturns true or false.\r\n\r\n```ruby\r\ntransaction.latest\r\n```\r\nReturns a `ItunesReceiptValidator::Transaction` by making a request to Apple's validation API and matches it with the `original_id`.\r\n\r\n### ItunesReceiptValidator::Transaction properties\r\n\r\n``` ruby\r\ntransaction.id\r\n```\r\nThe transaction identifier of the item that was purchased.\r\n\r\nSee [Transaction Identifier](https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW13).\r\n\r\n```ruby\r\ntransaction.original_id\r\n```\r\nFor a transaction that restores a previous transaction, the transaction identifier of the original transaction. Otherwise, identical to the transaction identifier.\r\n\r\nSee [Original Transaction Identifier](https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW14).\r\n\r\n```ruby\r\ntransaction.product_id\r\n```\r\nThe product identifier of the item that was purchased.\r\n\r\nSee [Product Identifier](https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW11).\r\n\r\n```ruby\r\ntransaction.quantity\r\n```\r\nThe number of items purchased.\r\n\r\nSee [Quantity](https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW10).\r\n\r\n```ruby\r\ntransaction.first_purchased_at\r\n```\r\nFor a transaction that restores a previous transaction, the date of the original transaction. Cast as a `Time` instance.\r\n\r\nSee [Original Purchase Date](https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW4).\r\n\r\n```ruby\r\ntransaction.purchased_at\r\n```\r\nThe date and time that the item was purchased. Cast as a `Time` instance.\r\n\r\nSee [Purchase Date](https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW15).\r\n\r\n```ruby\r\ntransaction.expires_at\r\n```\r\nThe expiration date for the subscription. Cast as a `Time` instance.\r\n\r\nSee [Subscription Expiration Date](https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW28).\r\n\r\n```ruby\r\ntransaction.cancelled_at\r\n```\r\nFor a transaction that was canceled by Apple customer support, the time and date of the cancellation. Cast as a `Time` instance.\r\n\r\nSee [Cancellation Date](https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW19).\r\n\r\n```ruby\r\ntransaction.web_order_line_item_id\r\n```\r\nThe primary key for identifying subscription purchases.\r\n\r\nSee [Web Order Line Item ID](https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW17).\r\n\r\n```ruby\r\ntransaction.trial_period\r\n```\r\n\r\nUndocumented with Apple.\r\n\r\n## Testing\r\n\r\n1. `bundle install`\r\n1. `rake`\r\n\r\n---\r\n\r\nCopyright 2015 [mbaasy.com](https://mbaasy.com/). This project is subject to the [MIT License](/LICENSE).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}